---
title: "Visualization scIB"
author: "Marta Interlandi"
date: "9/11/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r setup_environment, message=FALSE, warning=FALSE}
library(ggplot2)
library(cowplot)
library(fmsb)
library(dplyr)
library(tidyr)
library(ggforce)
library(tibble)
library(RColorBrewer)
library(dynutils)
#library(plyr)
library(stringr)
library(R.utils)

setwd("/home/python_scRNA/Munich/visualization/")
#source("./funky_heatmap.R")


```

# Read output dataframe of summary metrics


Metrics in group 1:
- PCR batch
- ASW label/batch
- iLISI
- kBet

Metrics group 2:
- NMI
- ARI
- ASW label
- cLISI
- CC conservation

```{r read}

metrics_tab_lab <- read.csv("./collected_metrics_2.csv")
methods <- colnames(metrics_tab_lab)[-1]
metrics <- as.character(metrics_tab_lab[,1])

metrics_tab <- t(metrics_tab_lab)
metrics_tab[metrics_tab == ""] <- NA
metrics_tab <- as.data.frame(metrics_tab[-1,])
colnames(metrics_tab) <- plyr::mapvalues(metrics, from = c("ASW_label", "ASW_label/batch", "cell_cycle_conservation"), to = c("Cell type ASW", "Batch ASW", "CC conservation"))
colnames(metrics_tab) <- sub("_", " ", colnames(metrics_tab))

method_names <- sapply(str_split(rownames(metrics_tab), "_"), function(x) x[1])
method_names <- capitalize(method_names)
method_names <- plyr::mapvalues(method_names, from = c("Seurat", "Mnn", "Bbknn", "Trvae"), to = c("Seurat v3", "MNN", "BBKNN", "TrVAE"))

hvg <- sapply(str_split(rownames(metrics_tab), "_"), function(x) x[2])
hvg <- plyr::mapvalues(hvg, from = c("hvg2000", "hvg0"), to = c("HVG", ""))
row_groups <- sapply(str_split(rownames(metrics_tab), "_"), function(x) x[3])

metrics_tab <- add_column(metrics_tab, "Method" = method_names, .before = 1)
bbknn_ind <- grep("bbknn", rownames(metrics_tab))
lisi_ind <- grep("LISI", colnames(metrics_tab))
metrics_tab[bbknn_ind, lisi_ind] <- NA

# reorder columns by groups
col.ordered <- c("Method", "PCR batch", "Batch ASW", "iLISI", "kBET", "NMI cluster/label", "ARI cluster/label", "Cell type ASW", "cLISI", "CC conservation")
metrics_tab <- metrics_tab[, col.ordered]

metrics_tab[,-1] <- as.numeric(as.matrix(metrics_tab[, -1]))
metrics_tab[,-1] <- apply(metrics_tab[,-1], 2, function(x) scale_minmax(x))

score_group1 <- rowMeans(metrics_tab[, 2:5], na.rm = T)
score_group2 <- rowMeans(metrics_tab[, 6:10], na.rm = T)
score_all <- rowMeans(metrics_tab[, 2:10], na.rm = T) 
metrics_tab <- add_column(metrics_tab, "Overall Score" = score_all, .after = "Method")
metrics_tab <- add_column(metrics_tab, "Batch Correction" = score_group1, .after = "Overall Score")
metrics_tab <- add_column(metrics_tab, "Bio conservation" = score_group2, .after = "kBET")

metrics_tab <- add_column(metrics_tab, "method_group" = row_groups, .after = "Method")
metrics_tab <- add_column(metrics_tab, "HVG_label" = hvg, .after = "method_group")



# order methods by the overall score
if(length(unique(score_all))!= 1){
  metrics_tab <- metrics_tab[order(metrics_tab$method_group, metrics_tab$`Overall Score`,  decreasing = T), ]
}

method_group <- plyr::mapvalues(metrics_tab$method_group, from = c("knn", "embed", "full"), to = c("KNN", "Embeddings", "Features"))
metrics_tab <- metrics_tab[, colnames(metrics_tab) != "method_group"]


```


# Defining column_info and row_info

```{r cndio}

row_height <- 1
row_space <- .1
row_bigspace <- .5
col_width <- 1
col_space <- .1
col_bigspace <- .5


process_geom_params <- function(column_info) {
  bind_cols(
    column_info %>% dplyr::select(-options),
    column_info %>% pull(options) %>% purrr::map_df(function(l) {
      if (length(l) == 0 || (length(l) == 1) && is.na(l)) {
        tibble(a = 1)[,integer(0)]
      } else {
        as_data_frame(l)
      }
    })
  )
}


add_column_if_missing <- function(df, ...) {
  column_values <- list(...)
  for (column_name in names(column_values)) {
    default_val <- rep(column_values[[column_name]], nrow(df))
    
    if (column_name %in% colnames(df)) {
      df[[column_name]] <- ifelse(is.na(df[[column_name]]), default_val, df[[column_name]])
    } else {
      df[[column_name]] <- default_val
    }
  }
  df
}

segment_data <- NULL


column_info <- data.frame(id = colnames(metrics_tab), name = colnames(metrics_tab), group = c("Text", "Text", "Score overall", rep("Removal of batch effects", 5), rep("Cell type label variance", 6)), geom = c("text", "text", "bar", "bar", rep("circle", 4), "bar", rep("circle", 5)))
                          
                          
                          
column_info$options <- list(list(width = 3, overlay = F, legend = F), list(width = 2, overlay = F, legend = T), list(width = 2, overlay = F, legend = T), list(width = 2, overlay = F, legend = T), list(width = 1, overlay = F, legend = T), list(width = 1, overlay = F, legend = T), list(width = 1, overlay = F, legend = T), list(width = 1, overlay = F, legend = T), list(width = 2, overlay = F, legend = T), list(width = 1, overlay = F, legend = T), list(width = 1, overlay = F, legend = F), list(width = 1, overlay = F, legend = F),list(width = 1, overlay = F, legend = F),list(width = 1, overlay = F, legend = F))



plot_table_metrics <- function(metrics_tab){ 
  
  palettes <- list("Score overall" = colorRampPalette(rev(brewer.pal(9, "YlGnBu")))(nrow(metrics_tab)),
                   "Removal of batch effects" = colorRampPalette(rev(brewer.pal(9, "BuPu")))(nrow(metrics_tab)),
                   "Cell type label variance" = colorRampPalette(rev(brewer.pal(9, "RdPu")))(nrow(metrics_tab)),
                   "legend" = colorRampPalette(rev(brewer.pal(9, "Greys")))(6))
  
  
  row_info <- data.frame(id = metrics_tab$Method, group = method_group)
  
  
  # DETERMINE ROW POSITIONS
  if (!"group" %in% colnames(row_info) || all(is.na(row_info$group))) {
    row_info$group <- ""
    row_groups <- tibble(group = "")
    plot_row_annotation <- FALSE
  } else {
    plot_row_annotation <- TRUE
  }
  
  row_pos <-
    row_info %>%
    group_by(group) %>%
    mutate(group_i = row_number()) %>%
    ungroup() %>%
    mutate(
      row_i = row_number(),
      colour_background = group_i %% 2 == 1,
      do_spacing = c(FALSE, diff(as.integer(factor(group))) != 0),
      ysep = ifelse(do_spacing, row_height + 2 * row_space, row_space),
      y = - (row_i * row_height + cumsum(ysep)),
      ymin = y - row_height / 2,
      ymax = y + row_height / 2
    )
  
  # DETERMINE COLUMN POSITIONS
  if (!"group" %in% colnames(column_info) || all(is.na(column_info$group))) {
    column_info$group <- ""
    plot_column_annotation <- FALSE
  } else {
    plot_column_annotation <- TRUE
  }
  
  column_info <-
    column_info %>%
    process_geom_params() %>%
    add_column_if_missing(width = col_width, overlay = FALSE, legend = TRUE)
  
  
  column_pos <-
    column_info %>%
    mutate(
      do_spacing = c(FALSE, diff(as.integer(factor(group))) != 0),
      xsep = case_when(
        overlay ~ c(0, -head(width, -1)),
        do_spacing ~ col_bigspace,
        TRUE ~ col_space
      ),
      xwidth = case_when(
        overlay & width < 0 ~ width - xsep,
        overlay ~ -xsep,
        TRUE ~ width
      ),
      xmax = cumsum(xwidth + xsep),
      xmin = xmax - xwidth,
      x = xmin + xwidth / 2
    )
  
  ##########################
  #### CREATE GEOM DATA ####
  ##########################
  
  # gather circle data
  ind_circle <- which(column_info$geom == "circle")
  dat_mat <- as.matrix(metrics_tab[, ind_circle])
  col_palette <- data.frame(metric = colnames(dat_mat), 
                            group = column_info[match(colnames(dat_mat), column_info$id), "group"])
  
  col_palette$palette <- lapply(col_palette$group, function(x) palettes[[as.character(x)]])
  
  circle_data <- data.frame(label = unlist(lapply(colnames(dat_mat), 
                                                  function(x) rep(x, nrow(dat_mat)))), 
                            x0 = unlist(lapply(column_pos$x[ind_circle], 
                                               function(x) rep(x, nrow(dat_mat)))), 
                            y0 = rep(row_pos$y, ncol(dat_mat)),
                            r = row_height/2*as.vector(dat_mat)
  )
  colors <- NULL
  for(i in 1:ncol(dat_mat)){
    palette <- col_palette$palette[[i]]
    colors <- c(colors, palette[rank(dat_mat[,i])])
  }
  
  circle_data$colors <- colors
  
  
  
  # gather bar data
  ind_bar <- which(column_info$geom == "bar")
  dat_mat <- as.matrix(metrics_tab[, ind_bar])
  
  col_palette <- data.frame(metric = colnames(dat_mat), 
                            group = column_info[match(colnames(dat_mat), column_info$id), "group"])
  
  col_palette$palette <- lapply(col_palette$group, function(x) palettes[[as.character(x)]])
  
  
  rect_data <- data.frame(label = unlist(lapply(colnames(dat_mat), 
                                                function(x) rep(x, nrow(dat_mat)))),
                          method = rep(row_info$id, ncol(dat_mat)),
                          value = as.vector(dat_mat),
                          xmin = unlist(lapply(column_pos[ind_bar, "xmin"], 
                                               function(x) rep(x, nrow(dat_mat)))),
                          xmax = unlist(lapply(column_pos[ind_bar, "xmax"], 
                                               function(x) rep(x, nrow(dat_mat)))),
                          ymin = rep(row_pos$ymin, ncol(dat_mat)),
                          ymax = rep(row_pos$ymax, ncol(dat_mat)),
                          xwidth = unlist(lapply(column_pos[ind_bar, "xwidth"], 
                                                 function(x) rep(x, nrow(dat_mat))))
  )
  rect_data <- rect_data %>%
    add_column_if_missing(hjust = 0) %>%
    mutate(
      xmin = xmin + (1 - value) * xwidth * hjust,
      xmax = xmax - (1 - value) * xwidth * (1 - hjust)
    )
  
  colors <- NULL
  for(i in 1:ncol(dat_mat)){
    palette <- col_palette$palette[[i]]
    colors <- c(colors, palette[rank(dat_mat[,i])])
  }
  
  rect_data$colors <- colors
  
  
  
  # gather text data
  ind_text <- which(column_info$geom == "text")
  dat_mat <- as.matrix(metrics_tab[, ind_text])
  
  text_data <- data.frame(label_value = as.vector(dat_mat), 
                          xmin = unlist(lapply(column_pos[ind_text, "xmin"], 
                                               function(x) rep(x, nrow(dat_mat)))),
                          xmax = unlist(lapply(column_pos[ind_text, "xmax"], 
                                               function(x) rep(x, nrow(dat_mat)))),
                          ymin = rep(row_pos$ymin, ncol(dat_mat)),
                          ymax = rep(row_pos$ymax, ncol(dat_mat)),
                          size = 4)
  
  text_data$colors <- NA
  text_data$colors <- ifelse(text_data$label_value == "HVG", "darkgreen", "black")
  
  
  # ADD COLUMN NAMES
  df <- column_pos %>% filter(name != "Method")
  # remove segment for HVG label
  df <- df[df$id != "HVG_label",]
  if (nrow(df) > 0) {
    segment_data <- segment_data %>% bind_rows(
      df %>% transmute(x = x, xend = x, y = -.3, yend = -.1, size = .5)
    )
    text_data <-
      bind_rows(
        text_data,
        df %>% transmute(
          xmin = x, xmax = x, ymin = 0, ymax = -0.5,
          angle = 30, vjust = 0, hjust = 0,
          label_value = name, 
          size = 3
        )
      )
  }
  
  # remove HVG_label
  text_data <- text_data[text_data$label_value != "HVG_label",]
  
  
  # GENERATE ROW ANNOTATION
  if (plot_row_annotation) {
    row_annotation <-
      row_pos %>% 
      select(group, ymin, ymax) %>%
      group_by(group) %>%
      summarise(
        ymin = min(ymin),
        ymax = max(ymax),
        y = (ymin + ymax) / 2
      ) %>%
      ungroup() %>%
      mutate(xmin = -.5, xmax = 5) %>%
      filter(!is.na(group), group != "")
    
    text_data <- text_data %>% bind_rows(
      row_annotation %>%
        transmute(xmin, xmax, ymin = ymax + row_space, label_value = group %>% gsub("\n", " ", .), 
                  hjust = 0, vjust = .5, fontface = "bold", size = 4) %>%
        mutate(ymax = ymin + row_height)
    )
  }
  
  
  
  # determine dsize of current geoms
  suppressWarnings({
    minimum_x <- min(column_pos$xmin, segment_data$x, segment_data$xend, circle_data$x - circle_data$r, 
                     text_data$xmin, na.rm = TRUE)
    maximum_x <- max(column_pos$xmax, segment_data$x, segment_data$xend, circle_data$x + circle_data$r, 
                     text_data$xmax, na.rm = TRUE)
    minimum_y <- min(row_pos$ymin, segment_data$y, segment_data$yend, circle_data$y - circle_data$r,  
                     text_data$ymin, na.rm = TRUE)
    maximum_y <- max(row_pos$ymax, segment_data$y, segment_data$yend,circle_data$y + circle_data$r,  
                     text_data$ymax, na.rm = TRUE)
  })
  
  ####################################
  ###   CREATE HARDCODED LEGENDS   ###
  ####################################
  
  middle_pos_y <- (maximum_y + minimum_y) /2
  legend_pos_x <- maximum_x +1
  
  # CREATE LEGEND for circle scores
  # circle legend
  legend_pos_y <- middle_pos_y - .5
  cir_minimum_x <- legend_pos_x
  
  cir_legend_size <- 1
  cir_legend_space <- .1
  
  cir_legend_dat <-
    data.frame(
      value = seq(0, 1, by = .2),
      xmin = cir_minimum_x, 
      ymin = legend_pos_y -1 
    )
  
  cir_legend_dat$r = row_height/2*cir_legend_dat$value
  
  x0 <- cir_legend_dat$r
  for(i in 1:length(cir_legend_dat$r)){
    if(i == 1){
      x0[i] <- cir_minimum_x + cir_legend_space + cir_legend_dat$r[i]
    }
    else {
      x0[i] <- x0[i-1] + cir_legend_dat$r[i-1] + cir_legend_space + cir_legend_dat$r[i]
    }
  }
  
  cir_legend_dat$x0 <- x0
  cir_legend_maxy <- legend_pos_y - 2.5
  cir_legend_dat$y0 <- cir_legend_maxy + cir_legend_dat$r
  
  cir_legend_dat$colors <- palettes[["legend"]]
  
  cir_maximum_x <- max(cir_legend_dat$x0)
  
  cir_title_data <-
    data_frame(xmin = cir_minimum_x, xmax = cir_maximum_x, ymin = legend_pos_y , ymax = legend_pos_y - 1, 
               label_value = "Score", hjust = 0, vjust = 1, fontface = "bold")
  
  cir_value_data <- data.frame(
    xmin = cir_legend_dat$x0 - cir_legend_dat$r,
    xmax = cir_legend_dat$x0 + cir_legend_dat$r,
    ymin = cir_legend_maxy - 1,
    ymax = cir_legend_maxy, 
    hjust = .5,
    vjust = 0,
    size = 2.5,
    label_value = ifelse(cir_legend_dat$value %in% c(0, 1), paste0(cir_legend_dat$value*100, "%"), 
                         "")
  )
  circle_data <- bind_rows(circle_data, cir_legend_dat)   
  text_data <- bind_rows(text_data, cir_title_data, cir_value_data)
  
  
  # CREATE LEGEND for ranking colors
  legend_pos_y <- middle_pos_y + .5
  rank_groups <- as.character(column_info[column_info$geom == "bar", "group"])
  rank_minimum_x <- legend_pos_x

  rank_maximum_x <- rank_minimum_x + 4
  
  rank_minimum_y <- list("Score overall" = legend_pos_y+3.5, 
                         "Removal of batch effects" = legend_pos_y + 2.5, 
                         "Cell type label variance" = legend_pos_y + 1.5)
    
  rank_title_data <- data.frame(xmin = rank_minimum_x, 
                                xmax = rank_maximum_x, 
                                ymin = legend_pos_y + 4.5, 
                                ymax = legend_pos_y + 3.5, 
                                label_value = "Ranking", 
                                hjust = 0, vjust = 0, 
                                fontface = "bold")
  
  for(rg in rank_groups){
    rank_palette <- palettes[[rg]][seq(1,length(palettes[[rg]]), length.out = 5)]
    
    rank_data <- data.frame(xmin = seq(rank_minimum_x, rank_minimum_x + 2, by = .5),
                            xmax = seq(rank_minimum_x + .5, rank_minimum_x + 2.5, by = .5),
                            ymin = rank_minimum_y[[rg]],
                            ymax = rank_minimum_y[[rg]] - .8,
                            border = FALSE,
                            colors = rank_palette
                            )
    rect_data <- bind_rows(rect_data, rank_data)
    
  }
  
  # create arrow for ranking
  
  arrow_data <- data.frame(x = rank_minimum_x, 
                           xend = rank_minimum_x + 2.5, 
                           y = legend_pos_y + 4, 
                           yend = legend_pos_y + 4)
  
  text_data <- bind_rows(text_data, rank_title_data)
  
  maximum_x <- max(maximum_x, max(text_data$xmax, na.rm = TRUE))
  
  
  ########################
  ##### COMPOSE PLOT #####
  ########################
  
  g <-
    ggplot() +
    coord_equal(expand = FALSE) +
    scale_alpha_identity() +
    scale_colour_identity() +
    scale_fill_identity() +
    scale_size_identity() +
    scale_linetype_identity() +
    cowplot::theme_nothing()
  
  # PLOT ROW BACKGROUNDS
  df <- row_pos %>% filter(colour_background)
  if (nrow(df) > 0) {
    g <- g + geom_rect(aes(xmin = min(column_pos$xmin)-.25, xmax = max(column_pos$xmax)+.25, ymin = ymin - (row_space / 2), ymax = ymax + (row_space / 2)), df, fill = "#DDDDDD")
  } 
  
  
  # PLOT CIRCLES
  if (nrow(circle_data) > 0) {
    g <- g + ggforce::geom_circle(aes(x0 = x0, y0 = y0, fill= colors, r = r), circle_data, size=.25)
  }
  
  
  # PLOT RECTANGLES
  if (nrow(rect_data) > 0) {
    # add defaults for optional values
    rect_data <- rect_data %>%
      add_column_if_missing(alpha = 1, border = TRUE, border_colour = "black") %>%
      mutate(border_colour = ifelse(border, border_colour, NA))
    
    g <- g + geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = colors, colour = border_colour, alpha = alpha), rect_data, size = .25)
  }
  
  
  # PLOT TEXT
  if (nrow(text_data) > 0) {
    # add defaults for optional values
    text_data <- text_data %>%
      add_column_if_missing(
        hjust = .5,
        vjust = .5,
        size = 3,
        fontface = "plain",
        colors = "black",
        lineheight = 1,
        angle = 0
      ) %>%
      mutate(
        angle2 = angle / 360 * 2 * pi,
        cosa = cos(angle2) %>% round(2),
        sina = sin(angle2) %>% round(2),
        alphax = ifelse(cosa < 0, 1 - hjust, hjust) * abs(cosa) + ifelse(sina > 0, 1 - vjust, vjust) * abs(sina),
        alphay = ifelse(sina < 0, 1 - hjust, hjust) * abs(sina) + ifelse(cosa < 0, 1 - vjust, vjust) * abs(cosa),
        x = (1 - alphax) * xmin + alphax * xmax,
        y = (1 - alphay) * ymin + alphay * ymax
      ) %>%
      filter(label_value != "")
    
    g <- g + geom_text(aes(x = x, y = y, label = label_value, colour = colors, hjust = hjust, vjust = vjust, size = size, fontface = fontface, angle = angle), data = text_data)
  }
  
  
  
  # PLOT SEGMENTS
  if (nrow(segment_data) > 0) {
    # add defaults for optional values
    segment_data <- segment_data %>% add_column_if_missing(size = .5, colour = "black", linetype = "solid")
    
    g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = size, colour = colour, linetype = linetype), segment_data)
  }
  
  # PLOT ARROW RANKING
  if (nrow(arrow_data) > 0) {
    # add defaults for optional values
    arrow_data <- arrow_data %>% add_column_if_missing(size = .5, colour = "black", linetype = "solid")
    
    g <- g + geom_segment(aes(x = x, xend = xend, y = y, yend = yend, size = size, colour = colour, linetype = linetype), arrow_data, arrow = arrow(length = unit(0.1, "cm")), lineend = "round", linejoin = "bevel")
  }
  
  # ADD SIZE
  # reserve a bit more room for text that wants to go outside the frame
  minimum_x <- minimum_x - 2
  maximum_x <- maximum_x + 3
  #if ("qc_cat_documentation" %in% column_info$id) maximum_x <- maximum_x + 2
  minimum_y <- minimum_y - 2
  maximum_y <- maximum_y + 3
  
  g$width <- maximum_x - minimum_x
  g$height <- maximum_y - minimum_y
  
  g <- g + expand_limits(x = c(minimum_x, maximum_x), y = c(minimum_y, maximum_y))
  return(g)
}

g <- plot_table_metrics(metrics_tab)  
ggsave("try_summary_metrics.pdf", g, device = cairo_pdf, width = g$width/4, height = g$height/4)
# 
# g <- plot_table_metrics(metr_full)  
# ggsave("full_summary_metrics.pdf", g, device = cairo_pdf, width = g$width/4, height = g$height/4)
# 
# g <- plot_table_metrics(metr_embed)  
# ggsave("embed_summary_metrics.pdf", g, device = cairo_pdf, width = g$width/4, height = g$height/4)
# 
# g <- plot_table_metrics(metr_knn)  
# ggsave("knn_summary_metrics.pdf", g, device = cairo_pdf, width = g$width/4, height = g$height/4)


```
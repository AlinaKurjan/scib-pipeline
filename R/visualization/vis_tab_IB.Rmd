---
title: "Visualization scIB"
author: "Marta Interlandi"
date: "9/11/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r setup_environment, message=FALSE, warning=FALSE}
library(ggplot2)
library(cowplot)
library(fmsb)
library(dplyr)
library(tidyr)
library(ggforce)
library(tibble)
library(RColorBrewer)
library(dynutils)
library(stringr)
library(R.utils)

setwd("/home/python_scRNA/Munich/visualization/")
source("./knit_table.R")


```

# Plot metrics summary table

Metrics in group 1:
- PCR batch
- ASW label/batch
- iLISI
- kBET

Metrics group 2:
- NMI
- ARI
- ASW label
- cLISI
- CC conservation
- Isolated labels F1
- isolated labels silhouette

```{r read}
## parameters for function
name_palette_all <- NULL
name_palette_batch <- NULL
name_palette_celltype <- NULL

# Load .csv file containing metrics 
metrics_tab_lab <- read.csv("./all_set.csv", sep = ",") ## change sep in case you have ","

# get metrics names from columns
metrics <- colnames(metrics_tab_lab)[-1]
metrics <- gsub("\\.", "/", metrics)
metrics <- gsub("_", " ", metrics)
metrics <- plyr::mapvalues(metrics, from = c("ASW label", "ASW label/batch", "cell cycle conservation"), to = c("Cell type ASW", "Batch ASW", "CC conservation"))

# metrics names as they are supposed to be ordered
ord.metrics.name <- c("PCR batch", "Batch ASW", "iLISI", "kBET", "NMI cluster/label", "ARI cluster/label", "Cell type ASW", "isolated label F1", "isolated label silhouette", "CC conservation","cLISI")


# how many metrics per group
# make this also parameters
metrics.group1 <- 4
metrics.group2 <- 7

# metrics present in the table
ord.metrics.name <- ord.metrics.name[1:(metrics.group1+metrics.group2)]


# get methods info from rownames
methods_info_full  <- as.character(metrics_tab_lab[,1])

# in case the names start with /
methods_info_full <- sub("/", "", methods_info_full)

# data scenarios to be saved in file name
data.scenarios <- unique(unlist(sapply(str_split(methods_info_full, "/"), function(x) x[1])))


###### Plot one figure for each data scenario

for (dt.sc in data.scenarios){
  ind.scen <- grep(paste0(dt.sc, "/"), methods_info_full)
  methods_info <- methods_info_full[ind.scen]
  metrics_tab_sub <- metrics_tab_lab[ind.scen, ]
  
  # info on scaling data
  scaling <- sapply(str_split(methods_info, "/"), function(x) x[3])

  
  # info on HVG selection
  hvg <- sapply(str_split(methods_info, "/"), function(x) x[4])
  hvg <- plyr::mapvalues(hvg, from = c("hvg", "full_feature"), to = c("HVG", "FULL"))
  
  methods <- sapply(str_split(methods_info, "/"), function(x) x[5])
  
  methods_name <- sapply(str_split(methods, "_"), function(x) x[1])
  methods_name <- capitalize(methods_name)
  methods_name <- plyr::mapvalues(methods_name, 
                                  from = c("Seurat", "Mnn", "Bbknn", "Trvae", "Scvi", "Liger", "Combat"), 
                                  to = c("Seurat v3", "MNN", "BBKNN", "TrVAE", "scVI", "LIGER", "ComBat"))
  
  
  method_groups <- sapply(str_split(methods, "_"), function(x) x[2])
  method_groups <- plyr::mapvalues(method_groups, 
                                   from = c("knn", "embed", "full"), 
                                   to = c("KNN", "embed", "features"))



  ##### Create dataframe 
  metrics_tab <- as.data.frame(metrics_tab_sub[, -1])
  metrics_tab[metrics_tab == ""] <- NA
  colnames(metrics_tab) <- metrics
  
  #add Methods column
  metrics_tab <- add_column(metrics_tab, "Method" = methods_name, .before = 1)

  # reorder columns by groups
  col.ordered <- c("Method", ord.metrics.name)
  metrics_tab <- metrics_tab[, col.ordered]

  ## Scores should be already scaled [0,1] - however, we aim to compute the scores based on the min-max scaled metrics
  scaled_metrics_tab <- as.matrix(metrics_tab[, -1])
  scaled_metrics_tab <- apply(scaled_metrics_tab, 2, function(x) scale_minmax(x))

  # calculate average score by group and overall
  score_group1 <- rowMeans(scaled_metrics_tab[, 1:metrics.group1], na.rm = T)
  score_group2 <- rowMeans(scaled_metrics_tab[, metrics.group2:ncol(scaled_metrics_tab)], 
                           na.rm = T)
 
  score_all <- (score_group1 + score_group2) / 2

  metrics_tab <- add_column(metrics_tab, "Overall Score" = score_all, .after = "Method")
  metrics_tab <- add_column(metrics_tab, "Batch Correction" = score_group1, .after = "Overall Score")
  metrics_tab <- add_column(metrics_tab, "Bio conservation" = score_group2, .after = "kBET")
  
  metrics_tab <- add_column(metrics_tab, "Output" = method_groups, .after = "Method")
  metrics_tab <- add_column(metrics_tab, "Features" = hvg, .after = "Output")
  metrics_tab <- add_column(metrics_tab, "Scaling" = scaling, .after = "Features")

  # order methods by the overall score
  #metrics_tab <- metrics_tab[order(metrics_tab$method_group, metrics_tab$`Overall Score`,  decreasing = T), ]
  metrics_tab <- metrics_tab[order(metrics_tab$`Overall Score`,  decreasing = T), ]
  
  # Defining column_info, row_info and palettes
  #row_info <- data.frame(id = metrics_tab$Method, group = metrics_tab$method_group)  
  row_info <- data.frame(id = metrics_tab$Method)
                         
  # remove column method_group that we needed only for ordering
  #metrics_tab <- metrics_tab[, colnames(metrics_tab) != "method_group"]
  
  column_info <- data.frame(id = colnames(metrics_tab),
                            group = c("Text", "Text", "Text", "Text", "Score overall", 
                                      rep("Removal of batch effects", (1+ metrics.group1)),
                                      rep("Cell type label variance", (1+metrics.group2))), 
                            geom = c("text", "text", "text", "text", "bar", "bar", rep("circle", metrics.group1), 
                                     "bar", rep("circle", metrics.group2)),
                            width = c(3.5,2.5,2,2.5,2,2, rep(1,metrics.group1), 2, rep(1,metrics.group2)),
                            overlay = F)
  
  # defining colors palette
  if(!is.null(name_palette_all)){
    palette.score.all <- colorRampPalette(rev(brewer.pal(9, name_palette_all)))(nrow(metrics_tab))
  } else{
    palette.score.all <- colorRampPalette(rev(brewer.pal(9, "YlGnBu")))(nrow(metrics_tab))
  }
  
  if(!is.null(name_palette_batch)){
    palette.score.batch <- colorRampPalette(rev(brewer.pal(9, name_palette_batch)))(nrow(metrics_tab))
  } else{
    palette.score.batch <- colorRampPalette(rev(brewer.pal(9, "BuPu")))(nrow(metrics_tab))
  }
  
  if(!is.null(name_palette_celltype)){
    palette.score.celltype <- colorRampPalette(rev(brewer.pal(9, name_palette_celltype)))(nrow(metrics_tab))
  } else{
    palette.score.celltype <- colorRampPalette(rev(brewer.pal(9, "RdPu")))(nrow(metrics_tab))
  }
  
  palettes <- list("Score overall" = palette.score.all,
                   "Removal of batch effects" = palette.score.batch,
                   "Cell type label variance" = palette.score.celltype)
  
  
  g <- scIB_knit_table(data = metrics_tab, column_info = column_info, row_info = row_info, palettes = palettes)  
  ggsave(paste0(dt.sc, "_summary_metrics.pdf"), g, device = cairo_pdf, width = g$width/4, height = g$height/4)



}



```


